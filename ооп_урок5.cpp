// ооп_урок5.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <Windows.h>

// перегрузка операторов:
// << - это перегруженный оператор побитового сдвига влево

class Digit
{
    int dig; // число
public:
    Digit() 
    { 
        dig = 0; 
    }                
    
    Digit(int iDig) 
    { 
        dig = iDig; 
    }  

    void Show() 
    { 
        std::cout << dig << "\n";
    }

    // перегружаем четыре оператора
    // все операторы бинарные, поэтому мы передаем в
    // них один параметр - это операнд, который будет
    // находится справа в выражении
    // левый операнд передается с помощью this

    Digit operator+(const Digit& N)  // здесь используется передача объекта по ссылке
    {                                // для того, чтобы не происходило копирование
        // на уровне реализации происходит передача сюда адреса передаваемого объекта
        // используется передача по ссылке, чтобы избежать затратной операции копирования
        // но будет работать и просто сonst Digit N, а не по ссылке
        // const - ссылка не сможет изменится, соотв. тот объект, на который
        // ссылается параметр N, тоже не будет изменен
        Digit temp;                        
        temp.dig = dig + N.dig;                        
        return temp; 
    }

    Digit operator-(const Digit& N)  // почему в эту и подобные ф-ии передаем только
    {                                 // один параметр N?
                                     // потому что 1-ый параметр и так является объектом
                                     // класса и благодаря указателю this он здесь известен и так    
        Digit temp;                        
        temp.dig = dig - N.dig;                        
        return temp; 
    }

    Digit operator*(const Digit& N) 
    { 
        Digit temp;                        
        temp.dig = dig * N.dig;                        
        return temp; 
    }

    Digit operator%(const Digit& N) 
    { 
        Digit temp;                        
        temp.dig = dig % N.dig;                        
        return temp; 

    }
};

int main3() 
{        
    // проверяем работу операторов        
    Digit A(8),B(3);        
    Digit C;        
    std::cout<<"\Digit A:\n";        
    A.Show();        
    std::cout<<"\Digit B:\n";        
    B.Show();        
    std::cout<<"\noperator+:\n";        
    C=
        A  // А - это тот объект, для которого будет вызыватся оператор +
        +
        B; // В - тот объект, который передается в виде параметра    
    // C = A + B  // аналогично A.operator+(B)
    C.Show();        
    std::cout<<"\noperator-:\n";        
    C=A-B;        
    C.Show();        
    std::cout << "\noperator*:\n";        
    C = A * B;        
    C.Show();        
    std::cout << "\noperator%:\n";        
    C = A % B;        
    C.Show(); 

    return 0;
}


/*
 Есть возможность создать ф-ию с именем operator знак 
*/
//////////////////////////////////////////////////////////////////////////////////

// конструктор копирования:
class string
{
    char* S;                    // указатель, чтобы хранить адрес динамически
                                // выделенного участка памяти для строки
    int len;                    // длина строки
public:
    string();                   // конструктор по умолчанию без параметров
     
    string(const char* s);      // перегруженный конструктор с параметрами
   
    string(const string& s);    // конструктор копирования
                                // принимает строку по ссылке и создает копию строки
                                // s - строка, которую мы будем копировать
   
    ~string()                   // деструктор
    {
        delete[] S;
    }

    void Sort(string s[], int n);   // метод сортировки

    const char* GetStr()const       // Константный метод возвращающий содержимое строки
    { 
        return S; 
    }

    void SetStr()                   // метод позволяющий изменить содержимое 
    {                               // с помощью пользователя
        if (S != nullptr)           // если строка не пустая - очистить
        {
            delete[] S;
        }
        char a[256];                // создаем буфер
        std::cin.getline(a, 256);   // запрашиваем у пользователя данные
        len = strlen(a) + 1;        // просчитываем размер буфера
        S = new char[len];          // выделяем память
        strcpy_s(S, len, a);        // переписываем в объект введенную строку
    }
    
    void SetStr2(char* str)         // метод позволяющий изменить содержимое
    {                               //  с помощью параметра
        if (S != nullptr)           // если строка не пустая - очистить
        {
            delete[] S;
        }
        len = strlen(str) + 1;      // просчитываем размер
        S = new char[len];          // выделяем память
        strcpy_s(S, len, str);      // переписываем в объект строку из параметра
    }
};

string::string()
{
    S = nullptr;  // начальная инициализация
    len = 0;      // начальная инициализация
}

string::string(const char* s)
{
    len = strlen(s) + 1;        
    S = new char[len + 1];
    strcpy_s(S, len, s);  // инициализация строкой, переданной пользователем
}

string::string(const string& s)
{
    len = s.len;  // берем из копируемой строки значение поля len
                  // и записываем в поле того объекта, для которого
                  // вызывается конструктор копирования
                  // len - это поле объекта копии, которая сейчас создается
                  //  конструктор копирования берет из копируемого объекта s
                  //  значение поля лен s.len и записывает это значение в поле
                  //  len объекта-копии
                  // В строке len = s.len происходит побитовое копирование,
                  //  а в S = new char[len + 1]; уже не происходит
    S = new char[len + 1];  // при копировании мы должны выделить
                            // новую область памяти для объекта-копии
    strcpy_s                // strcpy_s копирует содержимое копируемого
    (S, len+1, s.S);        //  объекта s.S и копирует в другою область
                            // памяти S, которую мы только что создали
}

void string::Sort(string s[], int n)
{
    //  Сортировка строк методом пузырька        
    string temp;           
    for(int i=0;i<n-1;i++)          
    {                
        for(int j=n-1;j>i;j--)                
        {                                                          
            if(strcmp(s[j].S,s[j-1].S)<0)  // сравнение двух строк                        
            { 
                temp.SetStr2(s[j].S);      // запись строки s[j] в temp                                                                   
                s[j].SetStr2(s[j-1].S);    // запись строки s[j-1] в s[j]                                                                           
                s[j-1].SetStr2(temp.S);    // запись строки temp в s[j-1]                        
            }                
        }        
    }
}

int main2()
{
    int n, i;
    std::cout << "Input the number of string s:\t";  // Вводим количество строк
    std::cin >> n;

    if (n < 0)
    {
        std::cout << "Error number:\t" << n << std::endl;
        return -1;
    }

    char c[2];                  // Забираем из потока символ Enter ("\n")
    std::cin.getline(c, 2);

    string* s = new string[n];  // cоздаем массив из n строк

    for (i = 0; i < n; i++)
    {
        s[i].SetStr();          // Ввод строк c клавиатуры
    }

    s->Sort(s, n);              // сортировка строк, вызов через указатель,        
                                // так как функция работает для группы объектов,
                                // а не для одного конкретного

    for (i = 0; i < n; i++)     // Вывод отсортированных строк
    {
        std::cout << "\n" << s[i].GetStr() << "\n";
    }

    delete[] s;                 // Удаление массива строк  
    return 0;
}

/*
 Конструктор копирования - любое копирование происходит путем вызова 
 (неявного для нас) конструктора копирования, который по умолчанию выполняет
 побитовое копирование.
 Но если мы хотим, что бы произошло глубокое (не побитовое) копирование,
 чтобы на поле объекта копи выделялась отдельная динамическая память и 
 скопировались бы все данные из 1го объекта во 2ой - тогда мы получим
 два разных объекта в динамической памяти. 
*/


//////////////////////////////////////////////////////////////////////////////

/*
  *Деструктор обязателен только тогда, когда нужно освобождать динамически
 выделяемую память. В других случаях, если мы не прописали деструктор, он все равно
 автоматически в классе есть и отрабатывает.

 При создании нескольких объектов одного класса у каждого объекта будут свои
 поля (и память на них выделяется своя), а методы будут одинаковы для этих
 объектов. Поэтому нет смысла дублировать в оперативной памяти все методы.

 Когда мы создаем конкретный объект - то на него нужны выделить отдельную
 память для того, чтобы была возможность внутри этого объекта хранить свои
 значения полей.

 Чтобы каждый метод "знал", для какого объекта он вызван, используется
 указатель this.
 Указатель this является неявным параметром каждого нестатического метода.

 *В статическом методе указатель this не определен - т.к. память на статический
  метод выделяется еще до создания первого объекта этого класса. Поэтому
  статическому методу и не нужен this, т.к. this - это указатель на конкретный
  объект, для которого вызывается метод.

 this - это указатель на тот объект, для которого вызывается метод.

 this это константный указатель (указатель, значением которого является
 фиксированный адрес), его нельзя перенаправить на другой объект.
 Так как this это параметр метода, то его область видимости ограничивается этим
 конкретным методом.
 this является ключевым словом.

 Какую проблему решает указатель this? - проблему дублирования методов класса в
 оперативной памяти - благодаря this каждая функция понимает, для какого
 объекта она вызвана.

 *Когда мы в main создаем объект класса, напр:
  int main()
  {
   Class obj;  // в этот момент выделилась память на все методы этого класса
  }

 *Например, мы можем обратиться к любому полю нашего класса так:
 void Output()
 {
    std::cout << this->a << std::endl;
 }
 аналогично обычному обращению:
 void Output()
 {
    std::cout << a << std::endl;  // происходит то же, что и при this->a
 }                                //  только в скрытом виде
 this-> - способ доступа к полю объекта через указатель под него


 Константный метод

 Через константный объект можно вызвать только константный метод.
 * Константный объект - это объект, поля которого мы не можем менять.
 Если в классе есть две функции с одним именем, и одна из них константная, а
 другая -  нет - то они являются перегруженными, потому что они принимают
 указатель this  разных типов.

 напр:
 class TestConstant
 {
    int a;
 }
 public:
    TestConstant()
    {
        a = 0;
    }
    void Output() const;  // ключевое слово const означает, что мы хотим, чтобы
    {                     // метод Output не имел возможности внутри себя
                          // изменять значение поля
       // a = 100;        // это будет работать (запуститься метод и при этом
                          // изменится значения объекта а, если не будет
                          // const в названии метода
       std::cout << a << std::endl;
    }

 *чтобы создать константный объект в main - пишем const TestConstant obj;

 Если ф-ия константная - то this является константным указателем на константу.
 Например, у нас есть две ф-ии с одним именем, одна константная, вторая нет,
 тогда они являются перегруженными, потому что принимают скрытый указатель
 this разных типов (и мы понимаем, что типы данных у этих ф-ий разные):

 void Output()
 {
    std::cout << this << endl;  // здесь this - константный указатель
    std::cout << a << std::endl;
 }

 void Output() const;
 {
    std::cout << this << endl;  // здесь this - константный указатель на константу
    std::cout << a << std::endl;
 }

*/

/////////////////////////////////////////////////////////////////////////////////

/* 
 Создайте класс Array.
Класс Array – это класс динамического массива. Размер массива может быть 
передан в конструктор в качестве параметра или задан с помощью вызова функции-члена.
Класс должен позволять заполнять массив значениями, отображать содержимое массива, 
изменять размер массива, сортировать массив, определять минимальное
и максимальное значение. Класс должен содержать набор конструкторов 
(конструктор копирования обязателен), деструктор
*/

class Array
{  
    int *arr;
    int count;
    
public:
    Array()
    {
        arr = nullptr;
        count = 0;
    }
    Array(int Count) {
       
        count = Count;
        arr = new int[Count];
        for (size_t i = 0; i < count; i++)
        {
            arr[i] = rand() % 30;
        }       
    }
  
    void output()
    {
        for (size_t i = 0; i < count; i++)
        {
            std::cout << arr[i] << " ";
        }
        std::cout << std::endl;
    }
    void sort()
    {
        for (size_t i = 0; i < count; i++)
        {
            for (size_t k = count - 1; k > i; k--)
            {
                
                if (arr[k - 1] > arr[k]) {
                    int temp = arr[k-1];
                    arr[k-1] = arr[k];
                    arr[k] = temp;
                }               
            }
            //std::cout << arr[i] << " ";
        }
        //std::cout << std::endl;
    }

    int Minimum()
    {
        int min = arr[0];
        for (int i = 0; i < count; i++)
        {
            if (min > arr[i])
            {
                min = arr[i];
            }
        }
        //std::cout << "Min: " << min << std::endl;
        return min;
    }

    Array(const Array& source)  // конструктор копирования
    {
        count = source.count;
        arr = new int[count];
        for (size_t i = 0; i < count; i++)
        {
            arr[i] = source.arr[i];
        }
    }

    ~Array()
    {
        delete[] arr;
    }
};

int main()
{
    srand(time(NULL));
    int size;
    std::cout << "Enter size: ";
    std::cin >> size;;
    
    Array arr1(size);
    //Array(count);  

    std::cout << "Array: " << std::endl;
    arr1.output();

    Array arr2(arr1);
    std::cout << "Copied array: " << std::endl;
    arr2.output();
    
    arr1.sort();
    std::cout << "Sorted array: " << std::endl;  
    arr1.output();

    
    std::cout << "Min element: " << arr1.Minimum() << std::endl;
    

	return 0;
}

